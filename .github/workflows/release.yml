name: Release

on:
  push:
    branches:
      - main


env:
  NODE_VERSION: 22
  DEPLOY_DIR: goblin-bot
  APP_NAME: goblin-bot

jobs:
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install
        run: npm ci

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: goblin-bot-${{ github.sha }}
          if-no-files-found: error
          path: |
            dist/
            package.json
            package-lock.json

  deploy-discord-commands:
    name: Deploy Discord commands
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install
        run: npm ci

      - name: Deploy
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_GUILD_ID: ${{ secrets.DISCORD_GUILD_ID }}
        run: |
          if [ -z "${DISCORD_GUILD_ID:-}" ]; then unset DISCORD_GUILD_ID; fi
          npm run deploy

  deploy-server:
    name: Deploy to server
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: goblin-bot-${{ github.sha }}

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_GUILD_ID: ${{ secrets.DISCORD_GUILD_ID }}
          CLASH_OF_CLANS_API_TOKEN: ${{ secrets.CLASH_OF_CLANS_API_TOKEN }}
          CLASH_OF_CLANS_API_BASE_URL: ${{ vars.CLASH_OF_CLANS_API_BASE_URL }}
          CLASH_OF_CLANS_API_TIMEOUT_MS: ${{ vars.CLASH_OF_CLANS_API_TIMEOUT_MS }}
          BOT_INSTANCE_LABEL: ${{ vars.BOT_INSTANCE_LABEL }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}
        run: |
          if [ -z "$SSH_HOST" ]; then
            echo "Missing required secret: SSH_HOST"
            exit 1
          fi

          echo "Deploying to $SSH_HOST:${{ env.DEPLOY_DIR }}"

          ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR "$SSH_HOST" "mkdir -p '${{ env.DEPLOY_DIR }}'"

          rsync -az --delete -e "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR" dist/ "$SSH_HOST":"${{ env.DEPLOY_DIR }}"/dist/
          rsync -az -e "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR" package.json package-lock.json "$SSH_HOST":"${{ env.DEPLOY_DIR }}"/

          ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR "$SSH_HOST" << ENDSSH
            set -euo pipefail
            
            DEPLOY_PATH="\$HOME/${{ env.DEPLOY_DIR }}"
            
            # Set environment variables for PM2
            export NODE_ENV="production"
            export DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            export APP_NAME="${{ env.APP_NAME }}"
            export NODE_VERSION="${{ env.NODE_VERSION }}"
            export DISCORD_TOKEN="${{ secrets.DISCORD_TOKEN }}"
            export DISCORD_CLIENT_ID="${{ secrets.DISCORD_CLIENT_ID }}"
            export DISCORD_GUILD_ID="${{ secrets.DISCORD_GUILD_ID }}"
            export CLASH_OF_CLANS_API_TOKEN="${{ secrets.CLASH_OF_CLANS_API_TOKEN }}"
            export CLASH_OF_CLANS_API_BASE_URL="${{ vars.CLASH_OF_CLANS_API_BASE_URL }}"
            export CLASH_OF_CLANS_API_TIMEOUT_MS="${{ vars.CLASH_OF_CLANS_API_TIMEOUT_MS }}"
            export BOT_INSTANCE_LABEL="${{ vars.BOT_INSTANCE_LABEL }}"
            export LOG_LEVEL="${{ vars.LOG_LEVEL }}"
            
            # Important: GitHub passes unset secrets/vars as empty strings. Our Zod env parsing
            # treats empty strings as "present", which breaks .optional() + .default().
            if [ -z "\${DISCORD_GUILD_ID:-}" ]; then unset DISCORD_GUILD_ID; fi
            if [ -z "\${CLASH_OF_CLANS_API_TOKEN:-}" ]; then unset CLASH_OF_CLANS_API_TOKEN; fi
            if [ -z "\${CLASH_OF_CLANS_API_BASE_URL:-}" ]; then unset CLASH_OF_CLANS_API_BASE_URL; fi
            if [ -z "\${CLASH_OF_CLANS_API_TIMEOUT_MS:-}" ]; then unset CLASH_OF_CLANS_API_TIMEOUT_MS; fi
            if [ -z "\${BOT_INSTANCE_LABEL:-}" ]; then unset BOT_INSTANCE_LABEL; fi
            if [ -z "\${LOG_LEVEL:-}" ]; then unset LOG_LEVEL; fi
            
            # Log environment variables (masking sensitive values)
            echo "=== Environment Variables ==="
            echo "DEPLOY_DIR=\$DEPLOY_DIR"
            echo "APP_NAME=\$APP_NAME"
            echo "NODE_VERSION=\$NODE_VERSION"
            echo "NODE_ENV=\$NODE_ENV"
            echo "DISCORD_TOKEN=\${DISCORD_TOKEN:+SET (\${#DISCORD_TOKEN} chars)}"
            echo "DISCORD_CLIENT_ID=\$DISCORD_CLIENT_ID"
            echo "DISCORD_GUILD_ID=\${DISCORD_GUILD_ID:-<not set>}"
            echo "CLASH_OF_CLANS_API_TOKEN=\${CLASH_OF_CLANS_API_TOKEN:+SET (\${#CLASH_OF_CLANS_API_TOKEN} chars)}"
            echo "CLASH_OF_CLANS_API_BASE_URL=\${CLASH_OF_CLANS_API_BASE_URL:-<not set>}"
            echo "CLASH_OF_CLANS_API_TIMEOUT_MS=\${CLASH_OF_CLANS_API_TIMEOUT_MS:-<not set>}"
            echo "BOT_INSTANCE_LABEL=\${BOT_INSTANCE_LABEL:-<not set>}"
            echo "LOG_LEVEL=\${LOG_LEVEL:-<not set>}"
            echo "============================="
            
            : "\${DISCORD_TOKEN:?Missing DISCORD_TOKEN (configure GitHub Secret)}"
            : "\${DISCORD_CLIENT_ID:?Missing DISCORD_CLIENT_ID (configure GitHub Secret)}"

            cd "\$DEPLOY_PATH"

            # Load nvm and use the correct Node version (same approach as SleepAPI)
            export NVM_DIR="\$HOME/.nvm"
            [ -s "\$NVM_DIR/nvm.sh" ] && \. "\$NVM_DIR/nvm.sh"

            # Use the Node version specified
            nvm install "${NODE_VERSION:-22}" || true
            nvm use "${NODE_VERSION:-22}"

            # Verify npm is available
            if ! command -v npm >/dev/null 2>&1; then
              echo "ERROR: npm is not available after nvm use"
              echo "HOME: \$HOME"
              echo "NVM_DIR: \$NVM_DIR"
              echo "PATH: \$PATH"
              echo "Node version: \$(command -v node || echo 'not found')"
              exit 1
            fi
            echo "Using Node.js \$(node --version) and npm \$(npm --version)"
            
            # Ensure npm global bin is in PATH (where pm2 would be installed)
            export PATH="\$(npm config get prefix)/bin:\$PATH"
            echo "npm global prefix: \$(npm config get prefix)"
            echo "Updated PATH: \$PATH"

            # Verify package files are present
            echo "Checking for package files in \$DEPLOY_PATH..."
            ls -la "\$DEPLOY_PATH" | grep -E "(package.json|package-lock.json)" || echo "WARNING: package files not found"
            
            if [ ! -f "\$DEPLOY_PATH/package-lock.json" ]; then
              echo "ERROR: package-lock.json not found in \$DEPLOY_PATH"
              echo "Contents of \$DEPLOY_PATH:"
              ls -la "\$DEPLOY_PATH"
              exit 1
            fi

            # Install build dependencies if not already present (needed for native modules)
            if ! command -v make >/dev/null 2>&1; then
              echo "Installing build dependencies..."
              if command -v apt-get >/dev/null 2>&1; then
                DEBIAN_FRONTEND=noninteractive apt-get update -qq
                DEBIAN_FRONTEND=noninteractive apt-get install -y -qq build-essential python3
              elif command -v yum >/dev/null 2>&1; then
                yum install -y -q gcc gcc-c++ make python3
              elif command -v apk >/dev/null 2>&1; then
                apk add --no-cache build-base python3
              fi
            fi

            npm ci --omit=dev

            # PM2 process management
            echo "=== PM2 Process Management ==="
            # Ensure npm global bin is in PATH (where pm2 should be)
            # nvm use should add this, but let's make sure
            NPM_GLOBAL_BIN="\$(npm config get prefix)/bin"
            if [[ ":\$PATH:" != *":\$NPM_GLOBAL_BIN:"* ]]; then
              export PATH="\$NPM_GLOBAL_BIN:\$PATH"
              echo "Added npm global bin to PATH: \$NPM_GLOBAL_BIN"
            fi
            
            # Check for pm2
            if ! command -v pm2 >/dev/null 2>&1; then
              echo "pm2 not found, installing globally..."
              npm install -g pm2
              # Refresh PATH after install
              export PATH="\$(npm config get prefix)/bin:\$PATH"
              if ! command -v pm2 >/dev/null 2>&1; then
                echo "ERROR: pm2 still not found after installation"
                echo "npm global prefix: \$(npm config get prefix)"
                echo "PATH: \$PATH"
                echo "Checking for pm2 in common locations:"
                ls -la "\$(npm config get prefix)/bin/pm2" 2>/dev/null || echo "  Not in npm global bin"
                ls -la "\$HOME/.nvm/versions/node/\$(node --version)/bin/pm2" 2>/dev/null || echo "  Not in nvm node bin"
                exit 1
              fi
              echo "✓ pm2 installed successfully"
            fi
            
            echo "pm2 is available at: \$(command -v pm2)"
            echo "pm2 version: \$(pm2 --version || echo 'unknown')"
            echo "Current PM2 processes:"
            pm2 list || echo "pm2 list failed (this is normal if no processes are running)"
              
              # Verify the entry point exists
              ENTRY_POINT="\$DEPLOY_PATH/dist/index.js"
              echo "Checking for entry point: \$ENTRY_POINT"
              if [ ! -f "\$ENTRY_POINT" ]; then
                echo "ERROR: Entry point not found at \$ENTRY_POINT"
                echo "Contents of \$DEPLOY_PATH/dist:"
                ls -la "\$DEPLOY_PATH/dist" 2>/dev/null || echo "dist directory does not exist"
                exit 1
              fi
              echo "✓ Entry point exists"
              
              # Check if process exists
              if pm2 describe "\$APP_NAME" > /dev/null 2>&1; then
                echo "Process '\$APP_NAME' exists, restarting..."
                pm2 restart "\$APP_NAME" --update-env
                RESTART_RESULT=\$?
                if [ \$RESTART_RESULT -ne 0 ]; then
                  echo "ERROR: pm2 restart failed with exit code \$RESTART_RESULT"
                  pm2 logs "\$APP_NAME" --lines 20 --nostream || true
                  exit 1
                fi
              else
                echo "Process '\$APP_NAME' does not exist, starting..."
                pm2 start "\$ENTRY_POINT" --name "\$APP_NAME" --time
                START_RESULT=\$?
                if [ \$START_RESULT -ne 0 ]; then
                  echo "ERROR: pm2 start failed with exit code \$START_RESULT"
                  pm2 logs "\$APP_NAME" --lines 20 --nostream || true
                  exit 1
                fi
              fi
              
              # Verify process is running
              echo "Verifying process status..."
              pm2 list
              if pm2 list | grep -q "\$APP_NAME.*online"; then
                echo "✓ Process '\$APP_NAME' is online"
                pm2 save
                echo "✓ PM2 process list saved"
              else
                echo "ERROR: Process '\$APP_NAME' is not online"
                echo "PM2 status:"
                pm2 describe "\$APP_NAME" || echo "pm2 describe failed"
                echo "Recent logs:"
                pm2 logs "\$APP_NAME" --lines 30 --nostream || echo "pm2 logs failed"
                exit 1
              fi
            echo "============================="
          ENDSSH
name: Release

on:
  push:
    branches:
      - main

concurrency:
  group: release-main
  cancel-in-progress: true

env:
  NODE_VERSION: 22
  # Remote deploy path (relative to SSH user's home directory)
  DEPLOY_DIR: goblin-bot
  # PM2 process name on the server
  APP_NAME: goblin-bot

jobs:
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install
        run: npm ci

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: goblin-bot-${{ github.sha }}
          if-no-files-found: error
          path: |
            dist/
            package.json
            package-lock.json

  deploy-discord-commands:
    name: Deploy Discord commands
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install
        run: npm ci

      - name: Deploy
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_GUILD_ID: ${{ secrets.DISCORD_GUILD_ID }}
        run: |
          if [ -z "${DISCORD_GUILD_ID:-}" ]; then unset DISCORD_GUILD_ID; fi
          npm run deploy

  deploy-server:
    name: Deploy to server
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: goblin-bot-${{ github.sha }}

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}
          DISCORD_GUILD_ID: ${{ secrets.DISCORD_GUILD_ID }}
          CLASH_OF_CLANS_API_TOKEN: ${{ secrets.CLASH_OF_CLANS_API_TOKEN }}
          CLASH_OF_CLANS_API_BASE_URL: ${{ vars.CLASH_OF_CLANS_API_BASE_URL }}
          CLASH_OF_CLANS_API_TIMEOUT_MS: ${{ vars.CLASH_OF_CLANS_API_TIMEOUT_MS }}
          BOT_INSTANCE_LABEL: ${{ vars.BOT_INSTANCE_LABEL }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}
        run: |
          if [ -z "$SSH_HOST" ]; then
            echo "Missing required secret: SSH_HOST"
            exit 1
          fi

          echo "Deploying to $SSH_HOST:${{ env.DEPLOY_DIR }}"

          ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR "$SSH_HOST" "mkdir -p '${{ env.DEPLOY_DIR }}'"

          rsync -az --delete -e "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR" dist/ "$SSH_HOST":"${{ env.DEPLOY_DIR }}"/dist/
          rsync -az -e "ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR" package.json package-lock.json "$SSH_HOST":"${{ env.DEPLOY_DIR }}"/

          ssh -o StrictHostKeyChecking=no -o LogLevel=ERROR "$SSH_HOST" "export DEPLOY_DIR='${{ env.DEPLOY_DIR }}' APP_NAME='${{ env.APP_NAME }}' NODE_VERSION='${{ env.NODE_VERSION }}' NODE_ENV='production' DISCORD_TOKEN='$DISCORD_TOKEN' DISCORD_CLIENT_ID='$DISCORD_CLIENT_ID' DISCORD_GUILD_ID='${DISCORD_GUILD_ID:-}' CLASH_OF_CLANS_API_TOKEN='${CLASH_OF_CLANS_API_TOKEN:-}' CLASH_OF_CLANS_API_BASE_URL='${CLASH_OF_CLANS_API_BASE_URL:-}' CLASH_OF_CLANS_API_TIMEOUT_MS='${CLASH_OF_CLANS_API_TIMEOUT_MS:-}' BOT_INSTANCE_LABEL='${BOT_INSTANCE_LABEL:-}' LOG_LEVEL='${LOG_LEVEL:-}'; bash -s" << 'ENDSSH'
            set -euo pipefail
            DEPLOY_PATH="$HOME/$DEPLOY_DIR"

            : "${DISCORD_TOKEN:?Missing DISCORD_TOKEN (configure GitHub Secret)}"
            : "${DISCORD_CLIENT_ID:?Missing DISCORD_CLIENT_ID (configure GitHub Secret)}"

            # Important: GitHub passes unset secrets/vars as empty strings. Our Zod env parsing
            # treats empty strings as "present", which breaks .optional() + .default().
            if [ -z "${DISCORD_GUILD_ID:-}" ]; then unset DISCORD_GUILD_ID; fi
            if [ -z "${CLASH_OF_CLANS_API_TOKEN:-}" ]; then unset CLASH_OF_CLANS_API_TOKEN; fi
            if [ -z "${CLASH_OF_CLANS_API_BASE_URL:-}" ]; then unset CLASH_OF_CLANS_API_BASE_URL; fi
            if [ -z "${CLASH_OF_CLANS_API_TIMEOUT_MS:-}" ]; then unset CLASH_OF_CLANS_API_TIMEOUT_MS; fi
            if [ -z "${BOT_INSTANCE_LABEL:-}" ]; then unset BOT_INSTANCE_LABEL; fi
            if [ -z "${LOG_LEVEL:-}" ]; then unset LOG_LEVEL; fi

            if [ -n "${NVM_DIR:-}" ] && [ -s "$NVM_DIR/nvm.sh" ]; then
              . "$NVM_DIR/nvm.sh"
            elif [ -s "$HOME/.nvm/nvm.sh" ]; then
              export NVM_DIR="$HOME/.nvm"
              . "$NVM_DIR/nvm.sh"
            fi

            cd "$DEPLOY_PATH"

            if command -v nvm >/dev/null 2>&1; then
              nvm install "${NODE_VERSION:-22}"
              nvm use "${NODE_VERSION:-22}"
            fi

            npm ci --omit=dev

            if command -v pm2 >/dev/null 2>&1; then
              if pm2 describe "$APP_NAME" > /dev/null 2>&1; then
                pm2 restart "$APP_NAME" --update-env
              else
                pm2 start "$DEPLOY_PATH/dist/index.js" --name "$APP_NAME" --time
              fi
              pm2 save
            else
              echo "pm2 is not installed on server; skipping process restart"
            fi
          ENDSSH
